(function() {
  var Graph, noflo,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  noflo = require("../lib/NoFlo");

  Graph = (function(superClass) {
    extend(Graph, superClass);

    function Graph(metadata1) {
      this.metadata = metadata1;
      this.network = null;
      this.ready = true;
      this.started = false;
      this.starting = false;
      this.baseDir = null;
      this.loader = null;
      this.load = 0;
      this.inPorts = new noflo.InPorts({
        graph: {
          datatype: 'all',
          description: 'NoFlo graph definition to be used with the subgraph component',
          required: true
        }
      });
      this.outPorts = new noflo.OutPorts;
      this.inPorts.graph.on('ip', (function(_this) {
        return function(packet) {
          if (packet.type !== 'data') {
            return;
          }
          return _this.setGraph(packet.data, function(err) {
            if (err) {
              return _this.error(err);
            }
          });
        };
      })(this));
    }

    Graph.prototype.setGraph = function(graph, callback) {
      this.ready = false;
      if (typeof graph === 'object') {
        if (typeof graph.addNode === 'function') {
          this.createNetwork(graph, callback);
          return;
        }
        noflo.graph.loadJSON(graph, (function(_this) {
          return function(err, instance) {
            if (err) {
              return callback(err);
            }
            instance.baseDir = _this.baseDir;
            return _this.createNetwork(instance, callback);
          };
        })(this));
        return;
      }
      if (graph.substr(0, 1) !== "/" && graph.substr(1, 1) !== ":" && process && process.cwd) {
        graph = (process.cwd()) + "/" + graph;
      }
      return noflo.graph.loadFile(graph, (function(_this) {
        return function(err, instance) {
          if (err) {
            return callback(err);
          }
          instance.baseDir = _this.baseDir;
          return _this.createNetwork(instance, callback);
        };
      })(this));
    };

    Graph.prototype.createNetwork = function(graph, callback) {
      this.description = graph.properties.description || '';
      this.icon = graph.properties.icon || this.icon;
      if (!graph.name) {
        graph.name = this.nodeId;
      }
      graph.componentLoader = this.loader;
      return noflo.createNetwork(graph, (function(_this) {
        return function(err, network1) {
          _this.network = network1;
          if (err) {
            return callback(err);
          }
          _this.emit('network', _this.network);
          _this.subscribeNetwork(_this.network);
          return _this.network.connect(function(err) {
            var name, node, ref;
            if (err) {
              return callback(err);
            }
            ref = _this.network.processes;
            for (name in ref) {
              node = ref[name];
              _this.findEdgePorts(name, node);
            }
            _this.setToReady();
            return callback();
          });
        };
      })(this), true);
    };

    Graph.prototype.subscribeNetwork = function(network) {
      var contexts;
      contexts = [];
      this.network.on('start', (function(_this) {
        return function() {
          var ctx;
          ctx = {};
          contexts.push(ctx);
          return _this.activate(ctx);
        };
      })(this));
      return this.network.on('end', (function(_this) {
        return function() {
          var ctx;
          ctx = contexts.pop();
          if (!ctx) {
            return;
          }
          return _this.deactivate(ctx);
        };
      })(this));
    };

    Graph.prototype.isExportedInport = function(port, nodeName, portName) {
      var exported, i, len, priv, pub, ref, ref1;
      ref = this.network.graph.inports;
      for (pub in ref) {
        priv = ref[pub];
        if (!(priv.process === nodeName && priv.port === portName)) {
          continue;
        }
        return pub;
      }
      ref1 = this.network.graph.exports;
      for (i = 0, len = ref1.length; i < len; i++) {
        exported = ref1[i];
        if (!(exported.process === nodeName && exported.port === portName)) {
          continue;
        }
        this.network.graph.checkTransactionStart();
        this.network.graph.removeExport(exported["public"]);
        this.network.graph.addInport(exported["public"], exported.process, exported.port, exported.metadata);
        this.network.graph.checkTransactionEnd();
        return exported["public"];
      }
      return false;
    };

    Graph.prototype.isExportedOutport = function(port, nodeName, portName) {
      var exported, i, len, priv, pub, ref, ref1;
      ref = this.network.graph.outports;
      for (pub in ref) {
        priv = ref[pub];
        if (!(priv.process === nodeName && priv.port === portName)) {
          continue;
        }
        return pub;
      }
      ref1 = this.network.graph.exports;
      for (i = 0, len = ref1.length; i < len; i++) {
        exported = ref1[i];
        if (!(exported.process === nodeName && exported.port === portName)) {
          continue;
        }
        this.network.graph.checkTransactionStart();
        this.network.graph.removeExport(exported["public"]);
        this.network.graph.addOutport(exported["public"], exported.process, exported.port, exported.metadata);
        this.network.graph.checkTransactionEnd();
        return exported["public"];
      }
      return false;
    };

    Graph.prototype.setToReady = function() {
      if (typeof process !== 'undefined' && process.execPath && process.execPath.indexOf('node') !== -1) {
        return process.nextTick((function(_this) {
          return function() {
            _this.ready = true;
            return _this.emit('ready');
          };
        })(this));
      } else {
        return setTimeout((function(_this) {
          return function() {
            _this.ready = true;
            return _this.emit('ready');
          };
        })(this), 0);
      }
    };

    Graph.prototype.findEdgePorts = function(name, process) {
      var inPorts, outPorts, port, portName, targetPortName;
      inPorts = process.component.inPorts.ports || process.component.inPorts;
      outPorts = process.component.outPorts.ports || process.component.outPorts;
      for (portName in inPorts) {
        port = inPorts[portName];
        targetPortName = this.isExportedInport(port, name, portName);
        if (targetPortName === false) {
          continue;
        }
        this.inPorts.add(targetPortName, port);
        this.inPorts[targetPortName].once('connect', (function(_this) {
          return function() {
            if (_this.starting) {
              return;
            }
            if (_this.isStarted()) {
              return;
            }
            return _this.start(function() {});
          };
        })(this));
      }
      for (portName in outPorts) {
        port = outPorts[portName];
        targetPortName = this.isExportedOutport(port, name, portName);
        if (targetPortName === false) {
          continue;
        }
        this.outPorts.add(targetPortName, port);
      }
      return true;
    };

    Graph.prototype.isReady = function() {
      return this.ready;
    };

    Graph.prototype.isSubgraph = function() {
      return true;
    };

    Graph.prototype.setUp = function(callback) {
      this.starting = true;
      if (!this.isReady()) {
        this.once('ready', (function(_this) {
          return function() {
            return _this.setUp(callback);
          };
        })(this));
        return;
      }
      if (!this.network) {
        return callback(null);
      }
      return this.network.start(function(err) {
        if (err) {
          return callback(err);
        }
        this.starting = false;
        return callback();
      });
    };

    Graph.prototype.tearDown = function(callback) {
      this.starting = false;
      if (!this.network) {
        return callback(null);
      }
      return this.network.stop(function(err) {
        if (err) {
          return callback(err);
        }
        return callback();
      });
    };

    return Graph;

  })(noflo.Component);

  exports.getComponent = function(metadata) {
    return new Graph(metadata);
  };

}).call(this);
