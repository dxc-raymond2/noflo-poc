var chai, noflo;

if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
  if (!chai) {
    chai = require('chai');
  }
  noflo = require('../src/lib/NoFlo.coffee');
} else {
  noflo = require('noflo');
}

describe('Component', function() {
  describe('with required ports', function() {
    it('should throw an error upon sending packet to an unattached required port', function() {
      var c, s2;
      s2 = new noflo.internalSocket.InternalSocket;
      c = new noflo.Component({
        outPorts: {
          required_port: {
            required: true
          },
          optional_port: {}
        }
      });
      c.outPorts.optional_port.attach(s2);
      return chai.expect(function() {
        return c.outPorts.required_port.send('foo');
      }).to["throw"]();
    });
    return it('should be cool with an attached port', function() {
      var c, f, s1, s2;
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      c = new noflo.Component({
        inPorts: {
          required_port: {
            required: true
          },
          optional_port: {}
        }
      });
      c.inPorts.required_port.attach(s1);
      c.inPorts.optional_port.attach(s2);
      f = function() {
        s1.send('some-more-data');
        return s2.send('some-data');
      };
      return chai.expect(f).to.not["throw"]();
    });
  });
  describe('with component creation shorthand', function() {
    it('should make component creation easy', function(done) {
      var c, s1, s2;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              return chai.expect(component).to.equal(c);
            }
          },
          just_processor: function(event, packet, component) {
            if (event !== 'data') {
              return;
            }
            chai.expect(packet).to.equal('some-data');
            chai.expect(component).to.equal(c);
            return done();
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      s2 = new noflo.internalSocket.InternalSocket;
      c.inPorts.just_processor.attach(s1);
      c.inPorts.just_processor.nodeInstance = c;
      s1.send('some-data');
      return s2.send('some-data');
    });
    it('should throw errors if there is no error port', function(done) {
      var c, s1;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              chai.expect(function() {
                return c.error(new Error);
              }).to["throw"](Error);
              return done();
            }
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    it('should throw errors if there is a non-attached error port', function(done) {
      var c, s1;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              chai.expect(function() {
                return c.error(new Error);
              }).to["throw"](Error);
              return done();
            }
          }
        },
        outPorts: {
          error: {
            datatype: 'object',
            required: true
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    it('should not throw errors if there is a non-required error port', function(done) {
      var c, s1;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              c.error(new Error);
              return done();
            }
          }
        },
        outPorts: {
          error: {
            required: false
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(s1);
      c.inPorts["in"].nodeInstance = c;
      return s1.send('some-data');
    });
    return it('should send errors if there is a connected error port', function(done) {
      var c, groups, grps, s1, s2;
      grps = [];
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true,
            process: function(event, packet, component) {
              if (event === 'begingroup') {
                grps.push(packet);
              }
              if (event !== 'data') {
                return;
              }
              chai.expect(packet).to.equal('some-data');
              chai.expect(component).to.equal(c);
              return c.error(new Error, grps);
            }
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      groups = ['foo', 'bar'];
      s2.on('begingroup', function(grp) {
        return chai.expect(grp).to.equal(groups.shift());
      });
      s2.on('data', function(err) {
        chai.expect(err).to.be.an.instanceOf(Error);
        chai.expect(groups.length).to.equal(0);
        return done();
      });
      c.inPorts["in"].attach(s1);
      c.outPorts.error.attach(s2);
      c.inPorts["in"].nodeInstance = c;
      s1.beginGroup('foo');
      s1.beginGroup('bar');
      return s1.send('some-data');
    });
  });
  describe('defining ports with invalid names', function() {
    it('should throw an error with uppercase letters in inport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new noflo.Component({
          inPorts: {
            fooPort: {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
    it('should throw an error with uppercase letters in outport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new noflo.Component({
          outPorts: {
            BarPort: {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
    return it('should throw an error with special characters in inport', function() {
      var shorthand;
      shorthand = function() {
        var c;
        return c = new noflo.Component({
          inPorts: {
            '$%^&*a': {}
          }
        });
      };
      return chai.expect(shorthand).to["throw"]();
    });
  });
  describe('starting a component', function() {
    return it('should flag the component as started', function(done) {
      var c, i;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        }
      });
      i = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(i);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        chai.expect(c.started).to.equal(true);
        chai.expect(c.isStarted()).to.equal(true);
        return done();
      });
    });
  });
  describe('shutting down a component', function() {
    return it('should flag the component as not started', function(done) {
      var c, i;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        }
      });
      i = new noflo.internalSocket.InternalSocket;
      c.inPorts["in"].attach(i);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        chai.expect(c.isStarted()).to.equal(true);
        return c.shutdown(function(err) {
          if (err) {
            return done(err);
          }
          chai.expect(c.started).to.equal(false);
          chai.expect(c.isStarted()).to.equal(false);
          return done();
        });
      });
    });
  });
  describe('with object-based IPs', function() {
    it('should speak IP objects', function(done) {
      var c, s1, s2;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            handle: function(ip, component) {
              chai.expect(ip).to.be.an('object');
              chai.expect(ip.type).to.equal('data');
              chai.expect(ip.groups).to.be.an('array');
              chai.expect(ip.groups).to.eql(['foo']);
              chai.expect(ip.data).to.be.a('string');
              chai.expect(ip.data).to.equal('some-data');
              return c.outPorts.out.data('bar', {
                groups: ['foo']
              });
            }
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      s2.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.groups).to.be.an('array');
        chai.expect(ip.groups).to.eql(['foo']);
        chai.expect(ip.data).to.be.a('string');
        chai.expect(ip.data).to.equal('bar');
        return done();
      });
      c.inPorts["in"].attach(s1);
      c.outPorts.out.attach(s2);
      return s1.post(new noflo.IP('data', 'some-data', {
        groups: ['foo']
      }));
    });
    return it('should support substreams', function(done) {
      var c, d, s1, s2, s3;
      c = new noflo.Component({
        inPorts: {
          tags: {
            datatype: 'string',
            handle: function(ip) {
              chai.expect(ip).to.be.an('object');
              switch (ip.type) {
                case 'openBracket':
                  c.str += "<" + ip.data + ">";
                  return c.level++;
                case 'data':
                  return c.str += ip.data;
                case 'closeBracket':
                  c.str += "</" + ip.data + ">";
                  c.level--;
                  if (c.level === 0) {
                    c.outPorts.html.data(c.str);
                    return c.str = '';
                  }
              }
            }
          }
        },
        outPorts: {
          html: {
            datatype: 'string'
          }
        }
      });
      c.str = '';
      c.level = 0;
      d = new noflo.Component({
        inPorts: {
          bang: {
            datatype: 'bang',
            handle: function(ip) {
              return d.outPorts.tags.openBracket('p').openBracket('em').data('Hello').closeBracket('em').data(', ').openBracket('strong').data('World!').closeBracket('strong').closeBracket('p');
            }
          }
        },
        outPorts: {
          tags: {
            datatype: 'string'
          }
        }
      });
      s1 = new noflo.internalSocket.InternalSocket;
      s2 = new noflo.internalSocket.InternalSocket;
      s3 = new noflo.internalSocket.InternalSocket;
      s3.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('<p><em>Hello</em>, <strong>World!</strong></p>');
        return done();
      });
      d.inPorts.bang.attach(s1);
      d.outPorts.tags.attach(s2);
      c.inPorts.tags.attach(s2);
      c.outPorts.html.attach(s3);
      return s1.post(new noflo.IP('data', 'start'));
    });
  });
  describe('with process function', function() {
    var c, sin1, sin2, sin3, sout1, sout2;
    c = null;
    sin1 = null;
    sin2 = null;
    sin3 = null;
    sout1 = null;
    sout2 = null;
    beforeEach(function(done) {
      sin1 = new noflo.internalSocket.InternalSocket;
      sin2 = new noflo.internalSocket.InternalSocket;
      sin3 = new noflo.internalSocket.InternalSocket;
      sout1 = new noflo.internalSocket.InternalSocket;
      sout2 = new noflo.internalSocket.InternalSocket;
      return done();
    });
    it('should trigger on IPs', function(done) {
      var count, hadIPs;
      hadIPs = [];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean'
          }
        },
        process: function(input, output) {
          hadIPs = [];
          if (input.has('foo')) {
            hadIPs.push('foo');
          }
          if (input.has('bar')) {
            hadIPs.push('bar');
          }
          return output.sendDone({
            baz: true
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        if (count === 1) {
          chai.expect(hadIPs).to.eql(['foo']);
        }
        if (count === 2) {
          chai.expect(hadIPs).to.eql(['foo', 'bar']);
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 'first'));
      return sin2.post(new noflo.IP('data', 'second'));
    });
    it('should trigger on IPs to addressable ports', function(done) {
      var count, receivedIndexes;
      receivedIndexes = [];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string',
            addressable: true
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean'
          }
        },
        process: function(input, output) {
          var indexToUse, indexesWithData, packet;
          indexesWithData = input.attached('foo').filter(function(idx) {
            return input.hasData(['foo', idx]);
          });
          if (!indexesWithData.length) {
            return;
          }
          indexToUse = indexesWithData[0];
          packet = input.get(['foo', indexToUse]);
          receivedIndexes.push({
            idx: indexToUse,
            payload: packet.data
          });
          return output.sendDone({
            baz: true
          });
        }
      });
      c.inPorts.foo.attach(sin1, 1);
      c.inPorts.foo.attach(sin2, 0);
      c.outPorts.baz.attach(sout1);
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        if (count === 1) {
          chai.expect(receivedIndexes).to.eql([
            {
              idx: 1,
              payload: 'first'
            }
          ]);
        }
        if (count === 2) {
          chai.expect(receivedIndexes).to.eql([
            {
              idx: 1,
              payload: 'first'
            }, {
              idx: 0,
              payload: 'second'
            }
          ]);
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 'first'));
      return sin2.post(new noflo.IP('data', 'second'));
    });
    it('should be able to send IPs to addressable connections', function(done) {
      var expected;
      expected = [
        {
          data: 'first',
          index: 1
        }, {
          data: 'second',
          index: 0
        }
      ];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean',
            addressable: true
          }
        },
        process: function(input, output) {
          var packet;
          if (!input.has('foo')) {
            return;
          }
          packet = input.get('foo');
          return output.sendDone(new noflo.IP('data', packet.data, {
            index: expected.length - 1
          }));
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1, 1);
      c.outPorts.baz.attach(sout2, 0);
      sout1.on('ip', function(ip) {
        var exp, received;
        exp = expected.shift();
        received = {
          data: ip.data,
          index: 1
        };
        chai.expect(received).to.eql(exp);
        if (!expected.length) {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        var exp, received;
        exp = expected.shift();
        received = {
          data: ip.data,
          index: 0
        };
        chai.expect(received).to.eql(exp);
        if (!expected.length) {
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 'first'));
      return sin1.post(new noflo.IP('data', 'second'));
    });
    it('trying to send to addressable port without providing index should fail', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean',
            addressable: true
          }
        },
        process: function(input, output) {
          var noIndex, packet;
          if (!input.hasData('foo')) {
            return;
          }
          packet = input.get('foo');
          noIndex = new noflo.IP('data', packet.data);
          chai.expect(function() {
            return output.sendDone(noIndex);
          }).to["throw"](Error);
          return done();
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1, 1);
      c.outPorts.baz.attach(sout2, 0);
      sout1.on('ip', function(ip) {});
      sout2.on('ip', function(ip) {});
      return sin1.post(new noflo.IP('data', 'first'));
    });
    it('should be able to send falsy IPs', function(done) {
      var expected;
      expected = [
        {
          port: 'out1',
          data: 1
        }, {
          port: 'out2',
          data: 0
        }
      ];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          }
        },
        outPorts: {
          out1: {
            datatype: 'int'
          },
          out2: {
            datatype: 'int'
          }
        },
        process: function(input, output) {
          var packet;
          if (!input.has('foo')) {
            return;
          }
          packet = input.get('foo');
          return output.sendDone({
            out1: 1,
            out2: 0
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.out1.attach(sout1, 1);
      c.outPorts.out2.attach(sout2, 0);
      sout1.on('ip', function(ip) {
        var exp, received;
        exp = expected.shift();
        received = {
          port: 'out1',
          data: ip.data
        };
        chai.expect(received).to.eql(exp);
        if (!expected.length) {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        var exp, received;
        exp = expected.shift();
        received = {
          port: 'out2',
          data: ip.data
        };
        chai.expect(received).to.eql(exp);
        if (!expected.length) {
          return done();
        }
      });
      return sin1.post(new noflo.IP('data', 'first'));
    });
    it('should not be triggered by non-triggering ports', function(done) {
      var count, triggered;
      triggered = [];
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string',
            triggering: false
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'boolean'
          }
        },
        process: function(input, output) {
          triggered.push(input.port.name);
          return output.sendDone({
            baz: true
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        if (count === 1) {
          chai.expect(triggered).to.eql(['bar']);
        }
        if (count === 2) {
          chai.expect(triggered).to.eql(['bar', 'bar']);
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 'first'));
      sin2.post(new noflo.IP('data', 'second'));
      sin1.post(new noflo.IP('data', 'first'));
      return sin2.post(new noflo.IP('data', 'second'));
    });
    it('should fetch undefined for premature data', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'boolean',
            triggering: false,
            control: true
          },
          baz: {
            datatype: 'string',
            triggering: false,
            control: true
          }
        },
        process: function(input, output) {
          var bar, baz, foo, ref;
          if (!input.has('foo')) {
            return;
          }
          ref = input.getData('foo', 'bar', 'baz'), foo = ref[0], bar = ref[1], baz = ref[2];
          chai.expect(foo).to.be.a('string');
          chai.expect(bar).to.be.undefined;
          chai.expect(baz).to.be.undefined;
          return done();
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.inPorts.baz.attach(sin3);
      sin1.post(new noflo.IP('data', 'AZ'));
      sin2.post(new noflo.IP('data', true));
      return sin3.post(new noflo.IP('data', 'first'));
    });
    it('should receive and send complete noflo.IP objects', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          ref = input.get('foo', 'bar'), foo = ref[0], bar = ref[1];
          baz = {
            foo: foo.data,
            bar: bar.data,
            groups: foo.groups,
            type: bar.type
          };
          return output.sendDone({
            baz: new noflo.IP('data', baz, {
              groups: ['baz']
            })
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        chai.expect(ip.data.groups).to.eql(['foo']);
        chai.expect(ip.data.type).to.equal('data');
        chai.expect(ip.groups).to.eql(['baz']);
        return done();
      });
      sin1.post(new noflo.IP('data', 'foo', {
        groups: ['foo']
      }));
      return sin2.post(new noflo.IP('data', 'bar', {
        groups: ['bar']
      }));
    });
    it('should stamp IP objects with the datatype of the outport when sending', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'all'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var foo;
          if (!input.has('foo')) {
            return;
          }
          foo = input.get('foo');
          return output.sendDone({
            baz: foo
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('foo');
        chai.expect(ip.datatype).to.equal('string');
        return done();
      });
      return sin1.post(new noflo.IP('data', 'foo'));
    });
    it('should stamp IP objects with the datatype of the inport when receiving', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'all'
          }
        },
        process: function(input, output) {
          var foo;
          if (!input.has('foo')) {
            return;
          }
          foo = input.get('foo');
          return output.sendDone({
            baz: foo
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('foo');
        chai.expect(ip.datatype).to.equal('string');
        return done();
      });
      return sin1.post(new noflo.IP('data', 'foo'));
    });
    it('should stamp IP objects with the schema of the outport when sending', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'all'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string',
            schema: 'text/markdown'
          }
        },
        process: function(input, output) {
          var foo;
          if (!input.has('foo')) {
            return;
          }
          foo = input.get('foo');
          return output.sendDone({
            baz: foo
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('foo');
        chai.expect(ip.datatype).to.equal('string');
        chai.expect(ip.schema).to.equal('text/markdown');
        return done();
      });
      return sin1.post(new noflo.IP('data', 'foo'));
    });
    it('should stamp IP objects with the schema of the inport when receiving', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string',
            schema: 'text/markdown'
          }
        },
        outPorts: {
          baz: {
            datatype: 'all'
          }
        },
        process: function(input, output) {
          var foo;
          if (!input.has('foo')) {
            return;
          }
          foo = input.get('foo');
          return output.sendDone({
            baz: foo
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('foo');
        chai.expect(ip.datatype).to.equal('string');
        chai.expect(ip.schema).to.equal('text/markdown');
        return done();
      });
      return sin1.post(new noflo.IP('data', 'foo'));
    });
    it('should receive and send just IP data if wanted', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          ref = input.getData('foo', 'bar'), foo = ref[0], bar = ref[1];
          baz = {
            foo: foo,
            bar: bar
          };
          return output.sendDone({
            baz: baz
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        return done();
      });
      sin1.post(new noflo.IP('data', 'foo', {
        groups: ['foo']
      }));
      return sin2.post(new noflo.IP('data', 'bar', {
        groups: ['bar']
      }));
    });
    it('should receive IPs and be able to selectively find them', function(done) {
      var called, shouldHaveSent;
      called = 0;
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, foo, validate;
          validate = function(ip) {
            called++;
            return ip.type === 'data' && ip.data === 'hello';
          };
          if (!input.has('foo', 'bar', validate)) {
            return;
          }
          foo = input.get('foo');
          while ((foo != null ? foo.type : void 0) !== 'data') {
            foo = input.get('foo');
          }
          bar = input.getData('bar');
          return output.sendDone({
            baz: foo.data + ":" + bar
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      shouldHaveSent = false;
      sout1.on('ip', function(ip) {
        chai.expect(shouldHaveSent, 'Should not sent before its time').to.equal(true);
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data).to.equal('hello:hello');
        chai.expect(called).to.equal(10);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('data', 'hello', sin1.post(new noflo.IP('closeBracket', 'a'))));
      shouldHaveSent = true;
      return sin2.post(new noflo.IP('data', 'hello'));
    });
    it('should keep last value for controls', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string',
            control: true
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          ref = input.getData('foo', 'bar'), foo = ref[0], bar = ref[1];
          baz = {
            foo: foo,
            bar: bar
          };
          return output.sendDone({
            baz: baz
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.data.foo).to.equal('boo');
          chai.expect(ip.data.bar).to.equal('bar');
          return done();
        });
      });
      sin1.post(new noflo.IP('data', 'foo'));
      sin2.post(new noflo.IP('data', 'bar'));
      return sin1.post(new noflo.IP('data', 'boo'));
    });
    it('should keep last data-typed IP packet for controls', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string',
            control: true
          }
        },
        outPorts: {
          baz: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var bar, baz, foo, ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          ref = input.getData('foo', 'bar'), foo = ref[0], bar = ref[1];
          baz = {
            foo: foo,
            bar: bar
          };
          return output.sendDone({
            baz: baz
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.data.foo).to.equal('foo');
        chai.expect(ip.data.bar).to.equal('bar');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.data.foo).to.equal('boo');
          chai.expect(ip.data.bar).to.equal('bar');
          return done();
        });
      });
      sin1.post(new noflo.IP('data', 'foo'));
      sin2.post(new noflo.IP('openBracket'));
      sin2.post(new noflo.IP('data', 'bar'));
      sin2.post(new noflo.IP('closeBracket'));
      return sin1.post(new noflo.IP('data', 'boo'));
    });
    it('should isolate packets with different scopes', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var bar, foo, ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          ref = input.getData('foo', 'bar'), foo = ref[0], bar = ref[1];
          return output.sendDone({
            baz: foo + " and " + bar
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.scope).to.equal('1');
        chai.expect(ip.data).to.equal('Josh and Laura');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.scope).to.equal('2');
          chai.expect(ip.data).to.equal('Jane and Luke');
          return done();
        });
      });
      sin1.post(new noflo.IP('data', 'Josh', {
        scope: '1'
      }));
      sin2.post(new noflo.IP('data', 'Luke', {
        scope: '2'
      }));
      sin2.post(new noflo.IP('data', 'Laura', {
        scope: '1'
      }));
      return sin1.post(new noflo.IP('data', 'Jane', {
        scope: '2'
      }));
    });
    it('should be able to change scope', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var foo;
          foo = input.getData('foo');
          return output.sendDone({
            baz: new noflo.IP('data', foo, {
              scope: 'baz'
            })
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.scope).to.equal('baz');
        chai.expect(ip.data).to.equal('foo');
        return done();
      });
      return sin1.post(new noflo.IP('data', 'foo', {
        scope: 'foo'
      }));
    });
    it('should support integer scopes', function(done) {
      c = new noflo.Component({
        inPorts: {
          foo: {
            datatype: 'string'
          },
          bar: {
            datatype: 'string'
          }
        },
        outPorts: {
          baz: {
            datatype: 'string'
          }
        },
        process: function(input, output) {
          var bar, foo, ref;
          if (!input.has('foo', 'bar')) {
            return;
          }
          ref = input.getData('foo', 'bar'), foo = ref[0], bar = ref[1];
          return output.sendDone({
            baz: foo + " and " + bar
          });
        }
      });
      c.inPorts.foo.attach(sin1);
      c.inPorts.bar.attach(sin2);
      c.outPorts.baz.attach(sout1);
      sout1.once('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.scope).to.equal(1);
        chai.expect(ip.data).to.equal('Josh and Laura');
        return sout1.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.type).to.equal('data');
          chai.expect(ip.scope).to.equal(0);
          chai.expect(ip.data).to.equal('Jane and Luke');
          return sout1.once('ip', function(ip) {
            chai.expect(ip).to.be.an('object');
            chai.expect(ip.type).to.equal('data');
            chai.expect(ip.scope).to.be["null"];
            chai.expect(ip.data).to.equal('Tom and Anna');
            return done();
          });
        });
      });
      sin1.post(new noflo.IP('data', 'Tom'));
      sin1.post(new noflo.IP('data', 'Josh', {
        scope: 1
      }));
      sin2.post(new noflo.IP('data', 'Luke', {
        scope: 0
      }));
      sin2.post(new noflo.IP('data', 'Laura', {
        scope: 1
      }));
      sin1.post(new noflo.IP('data', 'Jane', {
        scope: 0
      }));
      return sin2.post(new noflo.IP('data', 'Anna'));
    });
    it('should preserve order between input and output', function(done) {
      var ip, j, len, results, sample;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'object'
          }
        },
        ordered: true,
        process: function(input, output) {
          var delay, msg, ref;
          if (!input.has('msg', 'delay')) {
            return;
          }
          ref = input.getData('msg', 'delay'), msg = ref[0], delay = ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }
      ];
      sout1.on('ip', function(ip) {
        chai.expect(ip.data).to.eql(sample.shift());
        if (sample.length === 0) {
          return done();
        }
      });
      results = [];
      for (j = 0, len = sample.length; j < len; j++) {
        ip = sample[j];
        sin1.post(new noflo.IP('data', ip.msg));
        results.push(sin2.post(new noflo.IP('data', ip.delay)));
      }
      return results;
    });
    it('should ignore order between input and output', function(done) {
      var count, ip, j, len, results, sample;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'object'
          }
        },
        ordered: false,
        process: function(input, output) {
          var delay, msg, ref;
          if (!input.has('msg', 'delay')) {
            return;
          }
          ref = input.getData('msg', 'delay'), msg = ref[0], delay = ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }
      ];
      count = 0;
      sout1.on('ip', function(ip) {
        var src;
        count++;
        switch (count) {
          case 1:
            src = sample[1];
            break;
          case 2:
            src = sample[3];
            break;
          case 3:
            src = sample[2];
            break;
          case 4:
            src = sample[0];
        }
        chai.expect(ip.data).to.eql(src);
        if (count === 4) {
          return done();
        }
      });
      results = [];
      for (j = 0, len = sample.length; j < len; j++) {
        ip = sample[j];
        sin1.post(new noflo.IP('data', ip.msg));
        results.push(sin2.post(new noflo.IP('data', ip.delay)));
      }
      return results;
    });
    it('should throw errors if there is no error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(function() {
            return output.done(new Error('Should fail'));
          }).to["throw"](Error);
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      return sin1.post(new noflo.IP('data', 'some-data'));
    });
    it('should throw errors if there is a non-attached error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            datatype: 'object',
            required: true
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(function() {
            return output.sendDone(new Error('Should fail'));
          }).to["throw"](Error);
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      return sin1.post(new noflo.IP('data', 'some-data'));
    });
    it('should not throw errors if there is a non-required error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            required: false
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          output.sendDone(new Error('Should not fail'));
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      return sin1.post(new noflo.IP('data', 'some-data'));
    });
    it('should send out string other port if there is only one port aside from error', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'all',
            required: true
          }
        },
        outPorts: {
          out: {
            required: true
          },
          error: {
            required: false
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          return output.sendDone('some data');
        }
      });
      sout1.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.data).to.equal('some data');
        return done();
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      return sin1.post(new noflo.IP('data', 'first'));
    });
    it('should send object out other port if there is only one port aside from error', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'all',
            required: true
          }
        },
        outPorts: {
          out: {
            required: true
          },
          error: {
            required: false
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          return output.sendDone({
            some: 'data'
          });
        }
      });
      sout1.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.data).to.eql({
          some: 'data'
        });
        return done();
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      return sin1.post(new noflo.IP('data', 'first'));
    });
    it('should throw an error if sending without specifying a port and there are multiple ports', function(done) {
      var f;
      f = function() {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string',
              required: true
            }
          },
          outPorts: {
            out: {
              datatype: 'all'
            },
            eh: {
              required: false
            }
          },
          process: function(input, output) {
            return output.sendDone('test');
          }
        });
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'some-data'));
      };
      chai.expect(f).to["throw"](Error);
      return done();
    });
    it('should send errors if there is a connected error port', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(packet.scope).to.equal('some-scope');
          return output.sendDone(new Error('Should fail'));
        }
      });
      sout1.on('ip', function(ip) {
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.data).to.be.an.instanceOf(Error);
        chai.expect(ip.scope).to.equal('some-scope');
        return done();
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.error.attach(sout1);
      return sin1.post(new noflo.IP('data', 'some-data', {
        scope: 'some-scope'
      }));
    });
    it('should send substreams with multiple errors per activation', function(done) {
      var actual, count, expected;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            required: true
          }
        },
        outPorts: {
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var errors, packet;
          packet = input.get('in');
          chai.expect(packet.data).to.equal('some-data');
          chai.expect(packet.scope).to.equal('some-scope');
          errors = [];
          errors.push(new Error('One thing is invalid'));
          errors.push(new Error('Another thing is invalid'));
          return output.sendDone(errors);
        }
      });
      expected = ['<', 'One thing is invalid', 'Another thing is invalid', '>'];
      actual = [];
      count = 0;
      sout1.on('ip', function(ip) {
        count++;
        chai.expect(ip).to.be.an('object');
        chai.expect(ip.scope).to.equal('some-scope');
        if (ip.type === 'openBracket') {
          actual.push('<');
        }
        if (ip.type === 'closeBracket') {
          actual.push('>');
        }
        if (ip.type === 'data') {
          chai.expect(ip.data).to.be.an.instanceOf(Error);
          actual.push(ip.data.message);
        }
        if (count === 4) {
          chai.expect(actual).to.eql(expected);
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.error.attach(sout1);
      return sin1.post(new noflo.IP('data', 'some-data', {
        scope: 'some-scope'
      }));
    });
    it('should forward brackets for map-style components', function(done) {
      var actual, count, data, j, len, results, source;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          if (typeof str !== 'string') {
            return output.sendDone(new Error('Input is not string'));
          }
          return output.pass(str.toUpperCase());
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      source = ['<', 'foo', 'bar', '>'];
      actual = [];
      count = 0;
      sout1.on('ip', function(ip) {
        var data;
        data = (function() {
          switch (ip.type) {
            case 'openBracket':
              return '<';
            case 'closeBracket':
              return '>';
            default:
              return ip.data;
          }
        })();
        chai.expect(data).to.equal(source[count].toUpperCase());
        count++;
        if (count === 4) {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        if (ip.type !== 'data') {
          return;
        }
        console.log('Unexpected error', ip);
        return done(ip.data);
      });
      results = [];
      for (j = 0, len = source.length; j < len; j++) {
        data = source[j];
        switch (data) {
          case '<':
            results.push(sin1.post(new noflo.IP('openBracket')));
            break;
          case '>':
            results.push(sin1.post(new noflo.IP('closeBracket')));
            break;
          default:
            results.push(sin1.post(new noflo.IP('data', data)));
        }
      }
      return results;
    });
    it('should forward brackets for map-style components with addressable outport', function(done) {
      var expected, received, sent;
      sent = false;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string',
            addressable: true
          }
        },
        process: function(input, output) {
          var idx, string;
          if (!input.hasData()) {
            return;
          }
          string = input.getData();
          idx = sent ? 0 : 1;
          sent = true;
          return output.sendDone(new noflo.IP('data', string, {
            index: idx
          }));
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1, 1);
      c.outPorts.out.attach(sout2, 0);
      expected = ['1 < a', '1 < foo', '1 DATA first', '1 > foo', '0 < a', '0 < bar', '0 DATA second', '0 > bar', '0 > a', '1 > a'];
      received = [];
      sout1.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("1 < " + ip.data);
            break;
          case 'data':
            received.push("1 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("1 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sout2.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("0 < " + ip.data);
            break;
          case 'data':
            received.push("0 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("0 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('openBracket', 'foo'));
      sin1.post(new noflo.IP('data', 'first'));
      sin1.post(new noflo.IP('closeBracket', 'foo'));
      sin1.post(new noflo.IP('openBracket', 'bar'));
      sin1.post(new noflo.IP('data', 'second'));
      sin1.post(new noflo.IP('closeBracket', 'bar'));
      return sin1.post(new noflo.IP('closeBracket', 'a'));
    });
    it('should forward brackets for async map-style components with addressable outport', function(done) {
      var expected, received, sent;
      sent = false;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string',
            addressable: true
          }
        },
        process: function(input, output) {
          var idx, string;
          if (!input.hasData()) {
            return;
          }
          string = input.getData();
          idx = sent ? 0 : 1;
          sent = true;
          return setTimeout(function() {
            return output.sendDone(new noflo.IP('data', string, {
              index: idx
            }));
          }, 1);
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1, 1);
      c.outPorts.out.attach(sout2, 0);
      expected = ['1 < a', '1 < foo', '1 DATA first', '1 > foo', '0 < a', '0 < bar', '0 DATA second', '0 > bar', '0 > a', '1 > a'];
      received = [];
      sout1.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("1 < " + ip.data);
            break;
          case 'data':
            received.push("1 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("1 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sout2.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("0 < " + ip.data);
            break;
          case 'data':
            received.push("0 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("0 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('openBracket', 'foo'));
      sin1.post(new noflo.IP('data', 'first'));
      sin1.post(new noflo.IP('closeBracket', 'foo'));
      sin1.post(new noflo.IP('openBracket', 'bar'));
      sin1.post(new noflo.IP('data', 'second'));
      sin1.post(new noflo.IP('closeBracket', 'bar'));
      return sin1.post(new noflo.IP('closeBracket', 'a'));
    });
    it('should forward brackets for map-style components with addressable in/outports', function(done) {
      var expected, received;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            addressable: true
          }
        },
        outPorts: {
          out: {
            datatype: 'string',
            addressable: true
          }
        },
        process: function(input, output) {
          var data, idx, indexToUse, indexesWithData, ip, j, len, ref;
          indexesWithData = [];
          ref = input.attached();
          for (j = 0, len = ref.length; j < len; j++) {
            idx = ref[j];
            if (input.hasData(['in', idx])) {
              indexesWithData.push(idx);
            }
          }
          if (!indexesWithData.length) {
            return;
          }
          indexToUse = indexesWithData[0];
          data = input.get(['in', indexToUse]);
          ip = new noflo.IP('data', data.data);
          ip.index = indexToUse;
          return output.sendDone(ip);
        }
      });
      c.inPorts["in"].attach(sin1, 1);
      c.inPorts["in"].attach(sin2, 0);
      c.outPorts.out.attach(sout1, 1);
      c.outPorts.out.attach(sout2, 0);
      expected = ['1 < a', '1 < foo', '1 DATA first', '1 > foo', '0 < bar', '0 DATA second', '0 > bar', '1 > a'];
      received = [];
      sout1.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("1 < " + ip.data);
            break;
          case 'data':
            received.push("1 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("1 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sout2.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("0 < " + ip.data);
            break;
          case 'data':
            received.push("0 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("0 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('openBracket', 'foo'));
      sin1.post(new noflo.IP('data', 'first'));
      sin1.post(new noflo.IP('closeBracket', 'foo'));
      sin2.post(new noflo.IP('openBracket', 'bar'));
      sin2.post(new noflo.IP('data', 'second'));
      sin2.post(new noflo.IP('closeBracket', 'bar'));
      return sin1.post(new noflo.IP('closeBracket', 'a'));
    });
    it('should forward brackets for async map-style components with addressable in/outports', function(done) {
      var expected, received;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string',
            addressable: true
          }
        },
        outPorts: {
          out: {
            datatype: 'string',
            addressable: true
          }
        },
        process: function(input, output) {
          var data, idx, indexesWithData, j, len, ref;
          indexesWithData = [];
          ref = input.attached();
          for (j = 0, len = ref.length; j < len; j++) {
            idx = ref[j];
            if (input.hasData(['in', idx])) {
              indexesWithData.push(idx);
            }
          }
          if (!indexesWithData.length) {
            return;
          }
          data = input.get(['in', indexesWithData[0]]);
          return setTimeout(function() {
            var ip;
            ip = new noflo.IP('data', data.data);
            ip.index = data.index;
            return output.sendDone(ip);
          }, 1);
        }
      });
      c.inPorts["in"].attach(sin1, 1);
      c.inPorts["in"].attach(sin2, 0);
      c.outPorts.out.attach(sout1, 1);
      c.outPorts.out.attach(sout2, 0);
      expected = ['1 < a', '1 < foo', '1 DATA first', '1 > foo', '0 < bar', '0 DATA second', '0 > bar', '1 > a'];
      received = [];
      sout1.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("1 < " + ip.data);
            break;
          case 'data':
            received.push("1 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("1 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sout2.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("0 < " + ip.data);
            break;
          case 'data':
            received.push("0 DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("0 > " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('openBracket', 'foo'));
      sin1.post(new noflo.IP('data', 'first'));
      sin1.post(new noflo.IP('closeBracket', 'foo'));
      sin2.post(new noflo.IP('openBracket', 'bar'));
      sin2.post(new noflo.IP('data', 'second'));
      sin2.post(new noflo.IP('closeBracket', 'bar'));
      return sin1.post(new noflo.IP('closeBracket', 'a'));
    });
    it('should forward brackets to error port in async components', function(done) {
      var count;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          return setTimeout(function() {
            if (typeof str !== 'string') {
              return output.sendDone(new Error('Input is not string'));
            }
            return output.pass(str.toUpperCase());
          }, 10);
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sout1.on('ip', function(ip) {});
      count = 0;
      sout2.on('ip', function(ip) {
        count++;
        switch (count) {
          case 1:
            chai.expect(ip.type).to.equal('openBracket');
            break;
          case 2:
            chai.expect(ip.type).to.equal('data');
            chai.expect(ip.data).to.be.an('error');
            break;
          case 3:
            chai.expect(ip.type).to.equal('closeBracket');
        }
        if (count === 3) {
          return done();
        }
      });
      sin1.post(new noflo.IP('openBracket', 'foo'));
      sin1.post(new noflo.IP('data', {
        bar: 'baz'
      }));
      return sin1.post(new noflo.IP('closeBracket', 'foo'));
    });
    it('should not forward brackets if error port is not connected', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string',
            required: true
          },
          error: {
            datatype: 'object',
            required: true
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          return setTimeout(function() {
            if (typeof str !== 'string') {
              return output.sendDone(new Error('Input is not string'));
            }
            return output.pass(str.toUpperCase());
          }, 10);
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      sout1.on('ip', function(ip) {
        if (ip.type === 'closeBracket') {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        return done(new Error("Unexpected error IP: " + ip.type + " " + ip.data));
      });
      return chai.expect(function() {
        sin1.post(new noflo.IP('openBracket', 'foo'));
        sin1.post(new noflo.IP('data', 'bar'));
        return sin1.post(new noflo.IP('closeBracket', 'foo'));
      }).to.not["throw"]();
    });
    it('should support custom bracket forwarding mappings with auto-ordering', function(done) {
      var count, errCount, ip, j, len, sample;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        forwardBrackets: {
          msg: ['out', 'error'],
          delay: ['error']
        },
        process: function(input, output) {
          var delay, msg, ref;
          if (!input.hasData('msg', 'delay')) {
            return;
          }
          ref = input.getData('msg', 'delay'), msg = ref[0], delay = ref[1];
          if (delay < 0) {
            return output.sendDone(new Error('Delay is negative'));
          }
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }, {
          delay: -40,
          msg: 'five'
        }
      ];
      count = 0;
      errCount = 0;
      sout1.on('ip', function(ip) {
        var src;
        src = null;
        switch (count) {
          case 0:
            chai.expect(ip.type).to.equal('openBracket');
            chai.expect(ip.data).to.equal('msg');
            break;
          case 5:
            chai.expect(ip.type).to.equal('closeBracket');
            chai.expect(ip.data).to.equal('msg');
            break;
          default:
            src = sample[count - 1];
        }
        if (src) {
          chai.expect(ip.data).to.eql(src);
        }
        return count++;
      });
      sout2.on('ip', function(ip) {
        switch (errCount) {
          case 0:
            chai.expect(ip.type).to.equal('openBracket');
            chai.expect(ip.data).to.equal('msg');
            break;
          case 1:
            chai.expect(ip.type).to.equal('openBracket');
            chai.expect(ip.data).to.equal('delay');
            break;
          case 2:
            chai.expect(ip.type).to.equal('data');
            chai.expect(ip.data).to.be.an('error');
            break;
          case 3:
            chai.expect(ip.type).to.equal('closeBracket');
            chai.expect(ip.data).to.equal('delay');
            break;
          case 4:
            chai.expect(ip.type).to.equal('closeBracket');
            chai.expect(ip.data).to.equal('msg');
        }
        errCount++;
        if (errCount === 5) {
          return done();
        }
      });
      sin1.post(new noflo.IP('openBracket', 'msg'));
      sin2.post(new noflo.IP('openBracket', 'delay'));
      for (j = 0, len = sample.length; j < len; j++) {
        ip = sample[j];
        sin1.post(new noflo.IP('data', ip.msg));
        sin2.post(new noflo.IP('data', ip.delay));
      }
      sin2.post(new noflo.IP('closeBracket', 'delay'));
      return sin1.post(new noflo.IP('closeBracket', 'msg'));
    });
    it('should de-duplicate brackets when asynchronously forwarding from multiple inports', function(done) {
      var expected, received;
      c = new noflo.Component({
        inPorts: {
          in1: {
            datatype: 'string'
          },
          in2: {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        forwardBrackets: {
          in1: ['out', 'error'],
          in2: ['out', 'error']
        },
        process: function(input, output) {
          var one, ref, two;
          if (!input.hasData('in1', 'in2')) {
            return;
          }
          ref = input.getData('in1', 'in2'), one = ref[0], two = ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: one + ":" + two
            });
          }, 1);
        }
      });
      c.inPorts.in1.attach(sin1);
      c.inPorts.in2.attach(sin2);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sout2.on('ip', function(ip) {
        if (ip.type !== 'data') {
          return;
        }
        return done(ip.data);
      });
      expected = ['< a', '< b', 'DATA one:yksi', '< c', 'DATA two:kaksi', '> c', 'DATA three:kolme', '> b', '> a'];
      received = [];
      sout1.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("< " + ip.data);
            break;
          case 'data':
            received.push("DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("> " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('openBracket', 'b'));
      sin1.post(new noflo.IP('data', 'one'));
      sin1.post(new noflo.IP('openBracket', 'c'));
      sin1.post(new noflo.IP('data', 'two'));
      sin1.post(new noflo.IP('closeBracket', 'c'));
      sin2.post(new noflo.IP('openBracket', 'a'));
      sin2.post(new noflo.IP('openBracket', 'b'));
      sin2.post(new noflo.IP('data', 'yksi'));
      sin2.post(new noflo.IP('data', 'kaksi'));
      sin1.post(new noflo.IP('data', 'three'));
      sin1.post(new noflo.IP('closeBracket', 'b'));
      sin1.post(new noflo.IP('closeBracket', 'a'));
      sin2.post(new noflo.IP('data', 'kolme'));
      sin2.post(new noflo.IP('closeBracket', 'b'));
      return sin2.post(new noflo.IP('closeBracket', 'a'));
    });
    it('should de-duplicate brackets when synchronously forwarding from multiple inports', function(done) {
      var expected, received;
      c = new noflo.Component({
        inPorts: {
          in1: {
            datatype: 'string'
          },
          in2: {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        forwardBrackets: {
          in1: ['out', 'error'],
          in2: ['out', 'error']
        },
        process: function(input, output) {
          var one, ref, two;
          if (!input.hasData('in1', 'in2')) {
            return;
          }
          ref = input.getData('in1', 'in2'), one = ref[0], two = ref[1];
          return output.sendDone({
            out: one + ":" + two
          });
        }
      });
      c.inPorts.in1.attach(sin1);
      c.inPorts.in2.attach(sin2);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sout2.on('ip', function(ip) {
        if (ip.type !== 'data') {
          return;
        }
        return done(ip.data);
      });
      expected = ['< a', '< b', 'DATA one:yksi', '< c', 'DATA two:kaksi', '> c', 'DATA three:kolme', '> b', '> a'];
      received = [];
      sout1.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("< " + ip.data);
            break;
          case 'data':
            received.push("DATA " + ip.data);
            break;
          case 'closeBracket':
            received.push("> " + ip.data);
        }
        if (received.length !== expected.length) {
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      });
      sin1.post(new noflo.IP('openBracket', 'a'));
      sin1.post(new noflo.IP('openBracket', 'b'));
      sin1.post(new noflo.IP('data', 'one'));
      sin1.post(new noflo.IP('openBracket', 'c'));
      sin1.post(new noflo.IP('data', 'two'));
      sin1.post(new noflo.IP('closeBracket', 'c'));
      sin2.post(new noflo.IP('openBracket', 'a'));
      sin2.post(new noflo.IP('openBracket', 'b'));
      sin2.post(new noflo.IP('data', 'yksi'));
      sin2.post(new noflo.IP('data', 'kaksi'));
      sin1.post(new noflo.IP('data', 'three'));
      sin1.post(new noflo.IP('closeBracket', 'b'));
      sin1.post(new noflo.IP('closeBracket', 'a'));
      sin2.post(new noflo.IP('data', 'kolme'));
      sin2.post(new noflo.IP('closeBracket', 'b'));
      return sin2.post(new noflo.IP('closeBracket', 'a'));
    });
    it('should not apply auto-ordering if that option is false', function(done) {
      var count, ip, j, len, sample;
      c = new noflo.Component({
        inPorts: {
          msg: {
            datatype: 'string'
          },
          delay: {
            datatype: 'int'
          }
        },
        outPorts: {
          out: {
            datatype: 'object'
          }
        },
        ordered: false,
        autoOrdering: false,
        process: function(input, output) {
          var delay, msg, ref;
          if (input.ip.type !== 'data') {
            return input.get(input.port.name);
          }
          if (!input.has('msg', 'delay')) {
            return;
          }
          ref = input.getData('msg', 'delay'), msg = ref[0], delay = ref[1];
          return setTimeout(function() {
            return output.sendDone({
              out: {
                msg: msg,
                delay: delay
              }
            });
          }, delay);
        }
      });
      c.inPorts.msg.attach(sin1);
      c.inPorts.delay.attach(sin2);
      c.outPorts.out.attach(sout1);
      sample = [
        {
          delay: 30,
          msg: "one"
        }, {
          delay: 0,
          msg: "two"
        }, {
          delay: 20,
          msg: "three"
        }, {
          delay: 10,
          msg: "four"
        }
      ];
      count = 0;
      sout1.on('ip', function(ip) {
        var src;
        count++;
        switch (count) {
          case 1:
            src = sample[1];
            break;
          case 2:
            src = sample[3];
            break;
          case 3:
            src = sample[2];
            break;
          case 4:
            src = sample[0];
        }
        chai.expect(ip.data).to.eql(src);
        if (count === 4) {
          return done();
        }
      });
      sin1.post(new noflo.IP('openBracket', 'msg'));
      sin2.post(new noflo.IP('openBracket', 'delay'));
      for (j = 0, len = sample.length; j < len; j++) {
        ip = sample[j];
        sin1.post(new noflo.IP('data', ip.msg));
        sin2.post(new noflo.IP('data', ip.delay));
      }
      sin1.post(new noflo.IP('closeBracket', 'msg'));
      return sin2.post(new noflo.IP('closeBracket', 'delay'));
    });
    it('should forward noflo.IP metadata for map-style components', function(done) {
      var count, j, len, n, results, source, str;
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var str;
          str = input.getData();
          if (typeof str !== 'string') {
            return output.sendDone(new Error('Input is not string'));
          }
          return output.pass(str.toUpperCase());
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      source = ['foo', 'bar', 'baz'];
      count = 0;
      sout1.on('ip', function(ip) {
        chai.expect(ip.type).to.equal('data');
        chai.expect(ip.count).to.be.a('number');
        chai.expect(ip.length).to.be.a('number');
        chai.expect(ip.data).to.equal(source[ip.count].toUpperCase());
        chai.expect(ip.length).to.equal(source.length);
        count++;
        if (count === source.length) {
          return done();
        }
      });
      sout2.on('ip', function(ip) {
        console.log('Unexpected error', ip);
        return done(ip.data);
      });
      n = 0;
      results = [];
      for (j = 0, len = source.length; j < len; j++) {
        str = source[j];
        results.push(sin1.post(new noflo.IP('data', str, {
          count: n++,
          length: source.length
        })));
      }
      return results;
    });
    it('should be safe dropping IPs', function(done) {
      c = new noflo.Component({
        inPorts: {
          "in": {
            datatype: 'string'
          }
        },
        outPorts: {
          out: {
            datatype: 'string'
          },
          error: {
            datatype: 'object'
          }
        },
        process: function(input, output) {
          var data;
          data = input.get('in');
          data.drop();
          output.done();
          return done();
        }
      });
      c.inPorts["in"].attach(sin1);
      c.outPorts.out.attach(sout1);
      c.outPorts.error.attach(sout2);
      sout1.on('ip', function(ip) {
        return done(ip);
      });
      return sin1.post(new noflo.IP('data', 'foo', {
        meta: 'bar'
      }));
    });
    describe('with custom callbacks', function() {
      beforeEach(function(done) {
        c = new noflo.Component({
          inPorts: {
            foo: {
              datatype: 'string'
            },
            bar: {
              datatype: 'int',
              control: true
            }
          },
          outPorts: {
            baz: {
              datatype: 'object'
            },
            err: {
              datatype: 'object'
            }
          },
          ordered: true,
          activateOnInput: false,
          process: function(input, output) {
            var bar, baz, foo, ref;
            if (!input.has('foo', 'bar')) {
              return;
            }
            ref = input.getData('foo', 'bar'), foo = ref[0], bar = ref[1];
            if (bar < 0 || bar > 1000) {
              return output.sendDone({
                err: new Error("Bar is not correct: " + bar)
              });
            }
            input.activate();
            output.send({
              baz: new noflo.IP('openBracket')
            });
            baz = {
              foo: foo,
              bar: bar
            };
            output.send({
              baz: baz
            });
            return setTimeout(function() {
              output.send({
                baz: new noflo.IP('closeBracket')
              });
              return output.done();
            }, bar);
          }
        });
        c.inPorts.foo.attach(sin1);
        c.inPorts.bar.attach(sin2);
        c.outPorts.baz.attach(sout1);
        c.outPorts.err.attach(sout2);
        return done();
      });
      it('should fail on wrong input', function(done) {
        sout1.once('ip', function(ip) {
          return done(new Error('Unexpected baz'));
        });
        sout2.once('ip', function(ip) {
          chai.expect(ip).to.be.an('object');
          chai.expect(ip.data).to.be.an('error');
          chai.expect(ip.data.message).to.contain('Bar');
          return done();
        });
        sin1.post(new noflo.IP('data', 'fff'));
        return sin2.post(new noflo.IP('data', -120));
      });
      return it('should send substreams', function(done) {
        var actual, count, expected, item, j, len, results, sample;
        sample = [
          {
            bar: 30,
            foo: "one"
          }, {
            bar: 0,
            foo: "two"
          }
        ];
        expected = ['<', 'one', '>', '<', 'two', '>'];
        actual = [];
        count = 0;
        sout1.on('ip', function(ip) {
          count++;
          switch (ip.type) {
            case 'openBracket':
              actual.push('<');
              break;
            case 'closeBracket':
              actual.push('>');
              break;
            default:
              actual.push(ip.data.foo);
          }
          if (count === 6) {
            chai.expect(actual).to.eql(expected);
            return done();
          }
        });
        sout2.once('ip', function(ip) {
          return done(ip.data);
        });
        results = [];
        for (j = 0, len = sample.length; j < len; j++) {
          item = sample[j];
          sin2.post(new noflo.IP('data', item.bar));
          results.push(sin1.post(new noflo.IP('data', item.foo)));
        }
        return results;
      });
    });
    describe('using streams', function() {
      it('should not trigger without a full stream without getting the whole stream', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            if (input.hasStream('in')) {
              done(new Error('should never trigger this'));
            }
            if (input.has('in', function(ip) {
              return ip.type === 'closeBracket';
            })) {
              return done();
            }
          }
        });
        c.forwardBrackets = {};
        c.inPorts["in"].attach(sin1);
        sin1.post(new noflo.IP('openBracket'));
        sin1.post(new noflo.IP('openBracket'));
        sin1.post(new noflo.IP('openBracket'));
        sin1.post(new noflo.IP('data', 'eh'));
        return sin1.post(new noflo.IP('closeBracket'));
      });
      it('should trigger when forwardingBrackets because then it is only data with no brackets and is a full stream', function(done) {
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            if (!input.hasStream('in')) {
              return;
            }
            return done();
          }
        });
        c.forwardBrackets = {
          "in": ['out']
        };
        c.inPorts["in"].attach(sin1);
        return sin1.post(new noflo.IP('data', 'eh'));
      });
      it('should get full stream when it has a single packet stream and it should clear it', function(done) {
        c = new noflo.Component({
          inPorts: {
            eh: {
              datatype: 'string'
            }
          },
          outPorts: {
            canada: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var packetTypes, stream;
            if (!input.hasStream('eh')) {
              return;
            }
            stream = input.getStream('eh');
            packetTypes = stream.map(function(ip) {
              return [ip.type, ip.data];
            });
            chai.expect(packetTypes).to.eql([['data', 'moose']]);
            chai.expect(input.has('eh')).to.equal(false);
            return done();
          }
        });
        c.inPorts.eh.attach(sin1);
        return sin1.post(new noflo.IP('data', 'moose'));
      });
      it('should get full stream when it has a full stream, and it should clear it', function(done) {
        c = new noflo.Component({
          inPorts: {
            eh: {
              datatype: 'string'
            }
          },
          outPorts: {
            canada: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var packetTypes, stream;
            if (!input.hasStream('eh')) {
              return;
            }
            stream = input.getStream('eh');
            packetTypes = stream.map(function(ip) {
              return [ip.type, ip.data];
            });
            chai.expect(packetTypes).to.eql([['openBracket', null], ['openBracket', 'foo'], ['data', 'moose'], ['closeBracket', 'foo'], ['closeBracket', null]]);
            chai.expect(input.has('eh')).to.equal(false);
            return done();
          }
        });
        c.inPorts.eh.attach(sin1);
        sin1.post(new noflo.IP('openBracket'));
        sin1.post(new noflo.IP('openBracket', 'foo'));
        sin1.post(new noflo.IP('data', 'moose'));
        sin1.post(new noflo.IP('closeBracket', 'foo'));
        return sin1.post(new noflo.IP('closeBracket'));
      });
      return it('should get data when it has a full stream', function(done) {
        var expected, received;
        c = new noflo.Component({
          inPorts: {
            eh: {
              datatype: 'string'
            }
          },
          outPorts: {
            canada: {
              datatype: 'string'
            }
          },
          forwardBrackets: {
            eh: ['canada']
          },
          process: function(input, output) {
            var data;
            if (!input.hasStream('eh')) {
              return;
            }
            data = input.get('eh');
            chai.expect(data.type).to.equal('data');
            chai.expect(data.data).to.equal('moose');
            return output.sendDone(data);
          }
        });
        expected = [['openBracket', null], ['openBracket', 'foo'], ['data', 'moose'], ['closeBracket', 'foo'], ['closeBracket', null]];
        received = [];
        sout1.on('ip', function(ip) {
          received.push([ip.type, ip.data]);
          if (received.length !== expected.length) {
            return;
          }
          chai.expect(received).to.eql(expected);
          return done();
        });
        c.inPorts.eh.attach(sin1);
        c.outPorts.canada.attach(sout1);
        sin1.post(new noflo.IP('openBracket'));
        sin1.post(new noflo.IP('openBracket', 'foo'));
        sin1.post(new noflo.IP('data', 'moose'));
        sin1.post(new noflo.IP('closeBracket', 'foo'));
        return sin1.post(new noflo.IP('closeBracket'));
      });
    });
    return describe('with a simple ordered stream', function() {
      it('should send packets with brackets in expected order when synchronous', function(done) {
        var received;
        received = [];
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var data;
            if (!input.has('in')) {
              return;
            }
            data = input.getData('in');
            return output.sendDone({
              out: data
            });
          }
        });
        c.nodeId = 'Issue465';
        c.inPorts["in"].attach(sin1);
        c.outPorts.out.attach(sout1);
        sout1.on('ip', function(ip) {
          if (ip.type === 'openBracket') {
            if (!ip.data) {
              return;
            }
            received.push("< " + ip.data);
            return;
          }
          if (ip.type === 'closeBracket') {
            if (!ip.data) {
              return;
            }
            received.push("> " + ip.data);
            return;
          }
          return received.push(ip.data);
        });
        sout1.on('disconnect', function() {
          chai.expect(received).to.eql(['< 1', '< 2', 'A', '> 2', 'B', '> 1']);
          return done();
        });
        sin1.connect();
        sin1.beginGroup(1);
        sin1.beginGroup(2);
        sin1.send('A');
        sin1.endGroup();
        sin1.send('B');
        sin1.endGroup();
        return sin1.disconnect();
      });
      return it('should send packets with brackets in expected order when asynchronous', function(done) {
        var received;
        received = [];
        c = new noflo.Component({
          inPorts: {
            "in": {
              datatype: 'string'
            }
          },
          outPorts: {
            out: {
              datatype: 'string'
            }
          },
          process: function(input, output) {
            var data;
            if (!input.has('in')) {
              return;
            }
            data = input.getData('in');
            return setTimeout(function() {
              return output.sendDone({
                out: data
              });
            }, 1);
          }
        });
        c.nodeId = 'Issue465';
        c.inPorts["in"].attach(sin1);
        c.outPorts.out.attach(sout1);
        sout1.on('ip', function(ip) {
          if (ip.type === 'openBracket') {
            if (!ip.data) {
              return;
            }
            received.push("< " + ip.data);
            return;
          }
          if (ip.type === 'closeBracket') {
            if (!ip.data) {
              return;
            }
            received.push("> " + ip.data);
            return;
          }
          return received.push(ip.data);
        });
        sout1.on('disconnect', function() {
          chai.expect(received).to.eql(['< 1', '< 2', 'A', '> 2', 'B', '> 1']);
          return done();
        });
        sin1.connect();
        sin1.beginGroup(1);
        sin1.beginGroup(2);
        sin1.send('A');
        sin1.endGroup();
        sin1.send('B');
        sin1.endGroup();
        return sin1.disconnect();
      });
    });
  });
  return describe('with generator components', function() {
    var c, sin1, sin2, sin3, sout1, sout2;
    c = null;
    sin1 = null;
    sin2 = null;
    sin3 = null;
    sout1 = null;
    sout2 = null;
    before(function(done) {
      c = new noflo.Component({
        inPorts: {
          interval: {
            datatype: 'number',
            control: true
          },
          start: {
            datatype: 'bang'
          },
          stop: {
            datatype: 'bang'
          }
        },
        outPorts: {
          out: {
            datatype: 'bang'
          },
          err: {
            datatype: 'object'
          }
        },
        timer: null,
        ordered: false,
        autoOrdering: false,
        process: function(input, output, context) {
          var interval, start, stop;
          if (!input.has('interval')) {
            return;
          }
          if (input.has('start')) {
            start = input.get('start');
            interval = parseInt(input.getData('interval'));
            if (this.timer) {
              clearInterval(this.timer);
            }
            this.timer = setInterval(function() {
              context.activate();
              return setTimeout(function() {
                output.ports.out.sendIP(new noflo.IP('data', true));
                return context.deactivate();
              }, 5);
            }, interval);
          }
          if (input.has('stop')) {
            stop = input.get('stop');
            if (this.timer) {
              clearInterval(this.timer);
            }
          }
          return output.done();
        }
      });
      sin1 = new noflo.internalSocket.InternalSocket;
      sin2 = new noflo.internalSocket.InternalSocket;
      sin3 = new noflo.internalSocket.InternalSocket;
      sout1 = new noflo.internalSocket.InternalSocket;
      sout2 = new noflo.internalSocket.InternalSocket;
      c.inPorts.interval.attach(sin1);
      c.inPorts.start.attach(sin2);
      c.inPorts.stop.attach(sin3);
      c.outPorts.out.attach(sout1);
      c.outPorts.err.attach(sout2);
      return done();
    });
    it('should emit start event when started', function(done) {
      c.on('start', function() {
        chai.expect(c.started).to.be["true"];
        return done();
      });
      return c.start();
    });
    it('should emit activate/deactivate event on every tick', function(done) {
      var count, dcount;
      this.timeout(100);
      count = 0;
      dcount = 0;
      c.on('activate', function(load) {
        return count++;
      });
      c.on('deactivate', function(load) {
        dcount++;
        if (count === 3 && dcount === 3) {
          sin3.post(new noflo.IP('data', true));
          return done();
        }
      });
      sin1.post(new noflo.IP('data', 2));
      return sin2.post(new noflo.IP('data', true));
    });
    return it('should emit end event when stopped and no activate after it', function(done) {
      c.on('end', function() {
        chai.expect(c.started).to.be["false"];
        return done();
      });
      c.on('activate', function(load) {
        if (!c.started) {
          return done(new Error('Unexpected activate after end'));
        }
      });
      return c.shutdown(function(err) {
        if (err) {
          return done(err);
        }
      });
    });
  });
});
