var chai, legacyBasic, noflo, path, processAsync, processGenerator, processMerge, root, urlPrefix, wirePatternAsync, wirePatternMerge;

if (typeof process !== 'undefined' && process.execPath && process.execPath.match(/node|iojs/)) {
  if (!chai) {
    chai = require('chai');
  }
  noflo = require('../src/lib/NoFlo.coffee');
  path = require('path');
  root = path.resolve(__dirname, '../');
  urlPrefix = './';
} else {
  noflo = require('noflo');
  root = 'noflo';
  urlPrefix = '/';
}

legacyBasic = function() {
  var c;
  c = new noflo.Component;
  c.inPorts.add('in', {
    datatype: 'string'
  });
  c.outPorts.add('out', {
    datatype: 'string'
  });
  c.inPorts["in"].on('connect', function() {
    return c.outPorts.out.connect();
  });
  c.inPorts["in"].on('begingroup', function(group) {
    return c.outPorts.out.beginGroup(group);
  });
  c.inPorts["in"].on('data', function(data) {
    return c.outPorts.out.data(data + c.nodeId);
  });
  c.inPorts["in"].on('endgroup', function(group) {
    return c.outPorts.out.endGroup();
  });
  c.inPorts["in"].on('disconnect', function() {
    return c.outPorts.out.disconnect();
  });
  return c;
};

wirePatternAsync = function() {
  var c;
  c = new noflo.Component;
  c.inPorts.add('in', {
    datatype: 'string'
  });
  c.outPorts.add('out', {
    datatype: 'string'
  });
  return noflo.helpers.WirePattern(c, {
    "in": 'in',
    out: 'out',
    async: true,
    forwardGroups: true
  }, function(data, groups, out, callback) {
    return setTimeout(function() {
      out.send(data + c.nodeId);
      return callback();
    }, 1);
  });
};

wirePatternMerge = function() {
  var c;
  c = new noflo.Component;
  c.inPorts.add('in1', {
    datatype: 'string'
  });
  c.inPorts.add('in2', {
    datatype: 'string'
  });
  c.outPorts.add('out', {
    datatype: 'string'
  });
  return noflo.helpers.WirePattern(c, {
    "in": ['in1', 'in2'],
    out: 'out',
    async: true,
    forwardGroups: true
  }, function(data, groups, out, callback) {
    out.send("1" + data['in1'] + c.nodeId + "2" + data['in2'] + c.nodeId);
    return callback();
  });
};

processAsync = function() {
  var c;
  c = new noflo.Component;
  c.inPorts.add('in', {
    datatype: 'string'
  });
  c.outPorts.add('out', {
    datatype: 'string'
  });
  return c.process(function(input, output) {
    var data;
    data = input.getData('in');
    return setTimeout(function() {
      return output.sendDone(data + c.nodeId);
    }, 1);
  });
};

processMerge = function() {
  var c;
  c = new noflo.Component;
  c.inPorts.add('in1', {
    datatype: 'string'
  });
  c.inPorts.add('in2', {
    datatype: 'string'
  });
  c.outPorts.add('out', {
    datatype: 'string'
  });
  c.forwardBrackets = {
    'in1': ['out']
  };
  return c.process(function(input, output) {
    var first, second;
    if (!input.has('in1', 'in2', function(ip) {
      return ip.type === 'data';
    })) {
      return;
    }
    first = input.getData('in1');
    second = input.getData('in2');
    return output.sendDone({
      out: "1" + first + ":2" + second + ":" + c.nodeId
    });
  });
};

processGenerator = function() {
  var c, cleanUp;
  c = new noflo.Component;
  c.inPorts.add('start', {
    datatype: 'bang'
  });
  c.inPorts.add('stop', {
    datatype: 'bang'
  });
  c.outPorts.add('out', {
    datatype: 'bang'
  });
  c.autoOrdering = false;
  cleanUp = function() {
    if (!c.timer) {
      return;
    }
    clearInterval(c.timer.interval);
    c.timer.deactivate();
    return c.timer = null;
  };
  c.tearDown = function(callback) {
    cleanUp();
    return callback();
  };
  return c.process(function(input, output, context) {
    if (input.hasData('start')) {
      if (c.timer) {
        cleanUp();
      }
      input.getData('start');
      c.timer = context;
      c.timer.interval = setInterval(function() {
        return output.send({
          out: true
        });
      }, 100);
    }
    if (input.hasData('stop')) {
      input.getData('stop');
      if (!c.timer) {
        return output.done();
      }
      cleanUp();
      return output.done();
    }
  });
};

describe('Network Lifecycle', function() {
  var loader;
  loader = null;
  before(function(done) {
    loader = new noflo.ComponentLoader(root);
    return loader.listComponents(function(err) {
      if (err) {
        return done(err);
      }
      loader.registerComponent('wirepattern', 'Async', wirePatternAsync);
      loader.registerComponent('wirepattern', 'Merge', wirePatternMerge);
      loader.registerComponent('process', 'Async', processAsync);
      loader.registerComponent('process', 'Merge', processMerge);
      loader.registerComponent('process', 'Generator', processGenerator);
      loader.registerComponent('legacy', 'Sync', legacyBasic);
      return done();
    });
  });
  describe('with single Process API component receiving IIP', function() {
    var c, g, out;
    c = null;
    g = null;
    out = null;
    beforeEach(function(done) {
      var fbpData;
      fbpData = "OUTPORT=Pc.OUT:OUT 'hello' -> IN Pc(process/Async)";
      return noflo.graph.loadFBP(fbpData, function(err, graph) {
        if (err) {
          return done(err);
        }
        g = graph;
        loader.registerComponent('scope', 'Connected', graph);
        return loader.load('scope/Connected', function(err, instance) {
          if (err) {
            return done(err);
          }
          c = instance;
          out = noflo.internalSocket.createSocket();
          c.outPorts.out.attach(out);
          return done();
        });
      });
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should execute and finish', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['DATA helloPc'];
      received = [];
      out.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            return received.push("< " + ip.data);
          case 'data':
            return received.push("DATA " + ip.data);
          case 'closeBracket':
            return received.push('>');
        }
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
      });
    });
    it('should execute twice if IIP changes', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['DATA helloPc', 'DATA worldPc'];
      received = [];
      out.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            return received.push("< " + ip.data);
          case 'data':
            return received.push("DATA " + ip.data);
          case 'closeBracket':
            return received.push('>');
        }
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(wasStarted).to.equal(true);
        if (received.length < expected.length) {
          wasStarted = false;
          c.network.once('start', checkStart);
          c.network.once('end', checkEnd);
          g.addInitial('world', 'Pc', 'in');
          return;
        }
        chai.expect(received).to.eql(expected);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
      });
    });
    return it('should not send new IIP if network was stopped', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['DATA helloPc'];
      received = [];
      out.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            return received.push("< " + ip.data);
          case 'data':
            return received.push("DATA " + ip.data);
          case 'closeBracket':
            return received.push('>');
        }
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(wasStarted).to.equal(true);
        return c.network.stop(function(err) {
          if (err) {
            return done(err);
          }
          chai.expect(c.network.isStopped()).to.equal(true);
          c.network.once('start', function() {
            throw new Error('Unexpected network start');
          });
          c.network.once('end', function() {
            throw new Error('Unexpected network end');
          });
          g.addInitial('world', 'Pc', 'in');
          return setTimeout(function() {
            chai.expect(received).to.eql(expected);
            return done();
          }, 1000);
        });
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
      });
    });
  });
  describe('with WirePattern sending to Process API', function() {
    var c, ins, out;
    c = null;
    ins = null;
    out = null;
    before(function(done) {
      var fbpData;
      fbpData = "INPORT=Wp.IN:IN OUTPORT=Pc.OUT:OUT Wp(wirepattern/Async) OUT -> IN Pc(process/Async)";
      return noflo.graph.loadFBP(fbpData, function(err, g) {
        if (err) {
          return done(err);
        }
        loader.registerComponent('scope', 'Connected', g);
        return loader.load('scope/Connected', function(err, instance) {
          if (err) {
            return done(err);
          }
          c = instance;
          ins = noflo.internalSocket.createSocket();
          c.inPorts["in"].attach(ins);
          return done();
        });
      });
    });
    beforeEach(function() {
      out = noflo.internalSocket.createSocket();
      return c.outPorts.out.attach(out);
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should forward old-style groups as expected', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA bazWpPc', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        ins.connect();
        ins.beginGroup(1);
        ins.beginGroup('a');
        ins.send('baz');
        ins.endGroup();
        ins.endGroup();
        return ins.disconnect();
      });
    });
    it('should forward new-style brackets as expected', function(done) {
      var brackets, checkEnd, checkStart, expected, received, wasStarted;
      expected = ['< 1', '< a', 'DATA fooWpPc', '>', '>'];
      received = [];
      brackets = [];
      out.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push("< " + ip.data);
            return brackets.push(ip.data);
          case 'data':
            return received.push("DATA " + ip.data);
          case 'closeBracket':
            received.push('>');
            return brackets.pop();
        }
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        ins.post(new noflo.IP('openBracket', 1));
        ins.post(new noflo.IP('openBracket', 'a'));
        ins.post(new noflo.IP('data', 'foo'));
        ins.post(new noflo.IP('closeBracket', 'a'));
        return ins.post(new noflo.IP('closeBracket', 1));
      });
    });
    return it('should forward scopes as expected', function(done) {
      var brackets, checkEnd, checkStart, expected, received, wasStarted;
      expected = ['x < 1', 'x < a', 'x DATA barWpPc', 'x >', 'x >'];
      received = [];
      brackets = [];
      out.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push(ip.scope + " < " + ip.data);
            return brackets.push(ip.data);
          case 'data':
            return received.push(ip.scope + " DATA " + ip.data);
          case 'closeBracket':
            received.push(ip.scope + " >");
            return brackets.pop();
        }
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        ins.post(new noflo.IP('openBracket', 1, {
          scope: 'x'
        }));
        ins.post(new noflo.IP('openBracket', 'a', {
          scope: 'x'
        }));
        ins.post(new noflo.IP('data', 'bar', {
          scope: 'x'
        }));
        ins.post(new noflo.IP('closeBracket', 'a', {
          scope: 'x'
        }));
        return ins.post(new noflo.IP('closeBracket', 1, {
          scope: 'x'
        }));
      });
    });
  });
  describe('pure Process API merging two inputs', function() {
    var c, in1, in2, out;
    c = null;
    in1 = null;
    in2 = null;
    out = null;
    before(function(done) {
      var fbpData;
      fbpData = "INPORT=Pc1.IN:IN1 INPORT=Pc2.IN:IN2 OUTPORT=PcMerge.OUT:OUT Pc1(process/Async) OUT -> IN1 PcMerge(process/Merge) Pc2(process/Async) OUT -> IN2 PcMerge(process/Merge)";
      return noflo.graph.loadFBP(fbpData, function(err, g) {
        if (err) {
          return done(err);
        }
        loader.registerComponent('scope', 'Merge', g);
        return loader.load('scope/Merge', function(err, instance) {
          if (err) {
            return done(err);
          }
          c = instance;
          in1 = noflo.internalSocket.createSocket();
          c.inPorts.in1.attach(in1);
          in2 = noflo.internalSocket.createSocket();
          c.inPorts.in2.attach(in2);
          return done();
        });
      });
    });
    beforeEach(function() {
      out = noflo.internalSocket.createSocket();
      return c.outPorts.out.attach(out);
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should forward new-style brackets as expected', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazPc1:2fooPc2:PcMerge', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in2.connect();
        in2.send('foo');
        in2.disconnect();
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        return in1.disconnect();
      });
    });
    it('should forward new-style brackets as expected regardless of sending order', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazPc1:2fooPc2:PcMerge', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        in1.disconnect();
        in2.connect();
        in2.send('foo');
        return in2.disconnect();
      });
    });
    return it('should forward scopes as expected', function(done) {
      var brackets, checkEnd, checkStart, expected, received, wasStarted;
      expected = ['x < 1', 'x DATA 1onePc1:2twoPc2:PcMerge', 'x >'];
      received = [];
      brackets = [];
      out.on('ip', function(ip) {
        switch (ip.type) {
          case 'openBracket':
            received.push(ip.scope + " < " + ip.data);
            return brackets.push(ip.data);
          case 'data':
            return received.push(ip.scope + " DATA " + ip.data);
          case 'closeBracket':
            received.push(ip.scope + " >");
            return brackets.pop();
        }
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in2.post(new noflo.IP('data', 'two', {
          scope: 'x'
        }));
        in1.post(new noflo.IP('openBracket', 1, {
          scope: 'x'
        }));
        in1.post(new noflo.IP('data', 'one', {
          scope: 'x'
        }));
        return in1.post(new noflo.IP('closeBracket', 1, {
          scope: 'x'
        }));
      });
    });
  });
  describe('Process API mixed with legacy merging two inputs', function() {
    var c, in1, in2, out;
    c = null;
    in1 = null;
    in2 = null;
    out = null;
    before(function(done) {
      var fbpData;
      fbpData = "INPORT=Leg1.IN:IN1 INPORT=Leg2.IN:IN2 OUTPORT=Leg3.OUT:OUT Leg1(legacy/Sync) OUT -> IN1 PcMerge(process/Merge) Leg2(legacy/Sync) OUT -> IN2 PcMerge(process/Merge) PcMerge OUT -> IN Leg3(legacy/Sync)";
      return noflo.graph.loadFBP(fbpData, function(err, g) {
        if (err) {
          return done(err);
        }
        loader.registerComponent('scope', 'Merge', g);
        return loader.load('scope/Merge', function(err, instance) {
          if (err) {
            return done(err);
          }
          c = instance;
          in1 = noflo.internalSocket.createSocket();
          c.inPorts.in1.attach(in1);
          in2 = noflo.internalSocket.createSocket();
          c.inPorts.in2.attach(in2);
          return done();
        });
      });
    });
    beforeEach(function() {
      out = noflo.internalSocket.createSocket();
      return c.outPorts.out.attach(out);
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should forward new-style brackets as expected', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazLeg1:2fooLeg2:PcMergeLeg3', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in2.connect();
        in2.send('foo');
        in2.disconnect();
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        return in1.disconnect();
      });
    });
    return it('should forward new-style brackets as expected regardless of sending order', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazLeg1:2fooLeg2:PcMergeLeg3', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        in1.disconnect();
        in2.connect();
        in2.send('foo');
        return in2.disconnect();
      });
    });
  });
  describe('Process API mixed with Legacy and WirePattern merging two inputs', function() {
    var c, in1, in2, out;
    c = null;
    in1 = null;
    in2 = null;
    out = null;
    before(function(done) {
      var fbpData;
      fbpData = "INPORT=Leg1.IN:IN1 INPORT=Leg2.IN:IN2 OUTPORT=Wp.OUT:OUT Leg1(legacy/Sync) OUT -> IN1 PcMerge(process/Merge) Leg2(legacy/Sync) OUT -> IN2 PcMerge(process/Merge) PcMerge OUT -> IN Wp(wirepattern/Async)";
      return noflo.graph.loadFBP(fbpData, function(err, g) {
        if (err) {
          return done(err);
        }
        loader.registerComponent('scope', 'Merge', g);
        return loader.load('scope/Merge', function(err, instance) {
          if (err) {
            return done(err);
          }
          c = instance;
          in1 = noflo.internalSocket.createSocket();
          c.inPorts.in1.attach(in1);
          in2 = noflo.internalSocket.createSocket();
          c.inPorts.in2.attach(in2);
          return done();
        });
      });
    });
    beforeEach(function() {
      out = noflo.internalSocket.createSocket();
      return c.outPorts.out.attach(out);
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should forward new-style brackets as expected', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazLeg1:2fooLeg2:PcMergeWp', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in2.connect();
        in2.send('foo');
        in2.disconnect();
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        return in1.disconnect();
      });
    });
    return it('should forward new-style brackets as expected regardless of sending order', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazLeg1:2fooLeg2:PcMergeWp', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        in1.disconnect();
        in2.connect();
        in2.send('foo');
        return in2.disconnect();
      });
    });
  });
  describe('Process API mixed with WirePattern and legacy merging two inputs', function() {
    var c, in1, in2, out;
    c = null;
    in1 = null;
    in2 = null;
    out = null;
    before(function(done) {
      var fbpData;
      fbpData = "INPORT=Leg1.IN:IN1 INPORT=Leg2.IN:IN2 OUTPORT=Leg3.OUT:OUT Leg1(legacy/Sync) OUT -> IN1 PcMerge(process/Merge) Leg2(legacy/Sync) OUT -> IN2 PcMerge(process/Merge) PcMerge OUT -> IN Wp(wirepattern/Async) Wp OUT -> IN Leg3(legacy/Sync)";
      return noflo.graph.loadFBP(fbpData, function(err, g) {
        if (err) {
          return done(err);
        }
        loader.registerComponent('scope', 'Merge', g);
        return loader.load('scope/Merge', function(err, instance) {
          if (err) {
            return done(err);
          }
          c = instance;
          in1 = noflo.internalSocket.createSocket();
          c.inPorts.in1.attach(in1);
          in2 = noflo.internalSocket.createSocket();
          c.inPorts.in2.attach(in2);
          return done();
        });
      });
    });
    beforeEach(function() {
      out = noflo.internalSocket.createSocket();
      return c.outPorts.out.attach(out);
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should forward new-style brackets as expected', function(done) {
      var checkEnd, checkStart, expected, receiveConnect, receiveDisconnect, receiveEvent, received, wasStarted;
      expected = ['START', 'DATA -> IN Leg2() CONN', 'Leg2() OUT -> IN2 PcMerge() CONN', 'DATA -> IN Leg2() DATA foo', 'Leg2() OUT -> IN2 PcMerge() DATA fooLeg2', 'Leg2() OUT -> IN2 PcMerge() DISC', 'DATA -> IN Leg2() DISC', 'Leg1() OUT -> IN1 PcMerge() CONN', 'Leg1() OUT -> IN1 PcMerge() < 1', 'Leg1() OUT -> IN1 PcMerge() < a', 'Leg1() OUT -> IN1 PcMerge() DATA bazLeg1', 'PcMerge() OUT -> IN Wp() CONN', 'PcMerge() OUT -> IN Wp() < 1', 'PcMerge() OUT -> IN Wp() < a', 'PcMerge() OUT -> IN Wp() DATA 1bazLeg1:2fooLeg2:PcMerge', 'Leg1() OUT -> IN1 PcMerge() > a', 'PcMerge() OUT -> IN Wp() > a', 'Leg1() OUT -> IN1 PcMerge() > 1', 'PcMerge() OUT -> IN Wp() > 1', 'PcMerge() OUT -> IN Wp() DISC', 'Leg1() OUT -> IN1 PcMerge() DISC', 'Wp() OUT -> IN Leg3() CONN', 'Wp() OUT -> IN Leg3() < 1', 'Wp() OUT -> IN Leg3() < a', 'Wp() OUT -> IN Leg3() DATA 1bazLeg1:2fooLeg2:PcMergeWp', 'Wp() OUT -> IN Leg3() > a', 'Wp() OUT -> IN Leg3() > 1', 'Wp() OUT -> IN Leg3() DISC', 'END'];
      received = [];
      wasStarted = false;
      checkStart = function() {
        return received.push('START');
      };
      receiveConnect = function(event) {
        return received.push(event.id + " CONN");
      };
      receiveEvent = function(event) {
        var data, prefix;
        prefix = '';
        switch (event.type) {
          case 'openBracket':
            prefix = '<';
            data = prefix + " " + event.data;
            break;
          case 'data':
            prefix = 'DATA';
            data = prefix + " " + event.data;
            break;
          case 'closeBracket':
            prefix = '>';
            data = prefix + " " + event.data;
        }
        return received.push(event.id + " " + data);
      };
      receiveDisconnect = function(event) {
        return received.push(event.id + " DISC");
      };
      checkEnd = function() {
        received.push('END');
        c.network.graph.removeInitial('foo', 'Leg2', 'in');
        c.network.removeListener('connect', receiveConnect);
        c.network.removeListener('ip', receiveEvent);
        c.network.removeListener('disconnect', receiveDisconnect);
        chai.expect(received).to.eql(expected);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.on('connect', receiveConnect);
      c.network.on('ip', receiveEvent);
      c.network.on('disconnect', receiveDisconnect);
      c.network.once('end', checkEnd);
      c.network.graph.addInitial('foo', 'Leg2', 'in');
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        return in1.disconnect();
      });
    });
    return it('should forward new-style brackets as expected regardless of sending order', function(done) {
      var checkEnd, checkStart, expected, received, wasStarted;
      expected = ['CONN', '< 1', '< a', 'DATA 1bazLeg1:2fooLeg2:PcMergeWpLeg3', '>', '>', 'DISC'];
      received = [];
      out.on('connect', function() {
        return received.push('CONN');
      });
      out.on('begingroup', function(group) {
        return received.push("< " + group);
      });
      out.on('data', function(data) {
        return received.push("DATA " + data);
      });
      out.on('endgroup', function() {
        return received.push('>');
      });
      out.on('disconnect', function() {
        return received.push('DISC');
      });
      wasStarted = false;
      checkStart = function() {
        chai.expect(wasStarted).to.equal(false);
        return wasStarted = true;
      };
      checkEnd = function() {
        chai.expect(received).to.eql(expected);
        chai.expect(wasStarted).to.equal(true);
        return done();
      };
      c.network.once('start', checkStart);
      c.network.once('end', checkEnd);
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        in1.connect();
        in1.beginGroup(1);
        in1.beginGroup('a');
        in1.send('baz');
        in1.endGroup();
        in1.endGroup();
        in1.disconnect();
        in2.connect();
        in2.send('foo');
        return in2.disconnect();
      });
    });
  });
  return describe('with a Process API Generator component', function() {
    var c, out, start, stop;
    c = null;
    start = null;
    stop = null;
    out = null;
    before(function(done) {
      var fbpData;
      fbpData = "INPORT=PcGen.START:START INPORT=PcGen.STOP:STOP OUTPORT=Pc.OUT:OUT PcGen(process/Generator) OUT -> IN Pc(process/Async)";
      return noflo.graph.loadFBP(fbpData, function(err, g) {
        if (err) {
          return done(err);
        }
        loader.registerComponent('scope', 'Connected', g);
        return loader.load('scope/Connected', function(err, instance) {
          if (err) {
            return done(err);
          }
          return instance.once('ready', function() {
            c = instance;
            start = noflo.internalSocket.createSocket();
            c.inPorts.start.attach(start);
            stop = noflo.internalSocket.createSocket();
            c.inPorts.stop.attach(stop);
            return done();
          });
        });
      });
    });
    beforeEach(function() {
      out = noflo.internalSocket.createSocket();
      return c.outPorts.out.attach(out);
    });
    afterEach(function(done) {
      c.outPorts.out.detach(out);
      out = null;
      return c.shutdown(done);
    });
    it('should not be running initially', function() {
      return chai.expect(c.network.isRunning()).to.equal(false);
    });
    it('should not be running even when network starts', function(done) {
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        chai.expect(c.network.isRunning()).to.equal(false);
        return done();
      });
    });
    it('should start generating when receiving a start packet', function(done) {
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        out.once('data', function() {
          chai.expect(c.network.isRunning()).to.equal(true);
          return done();
        });
        return start.send(true);
      });
    });
    return it('should stop generating when receiving a stop packet', function(done) {
      return c.start(function(err) {
        if (err) {
          return done(err);
        }
        out.once('data', function() {
          chai.expect(c.network.isRunning()).to.equal(true);
          stop.send(true);
          return setTimeout(function() {
            chai.expect(c.network.isRunning()).to.equal(false);
            return done();
          }, 10);
        });
        return start.send(true);
      });
    });
  });
});
